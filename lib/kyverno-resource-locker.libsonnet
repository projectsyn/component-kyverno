/**
 * \file Library with public methods provided by component patch-operator.
 */

local kap = import 'lib/kapitan.libjsonnet';
local kube = import 'lib/kube.libjsonnet';
local kyverno = import 'lib/kyverno.libsonnet';

local inv = kap.inventory();
local kyverno_params = inv.parameters.kyverno;
local namespace = kyverno_params.namespace;
local instance = inv.parameters._instance;

local apiVersion = 'redhatcop.redhat.io/v1alpha1';

local render_patch(patch, _, patch_id='patch1') =
  { [patch_id]: patch };


local targetData(obj) =
  local apigrp = std.split(obj.apiVersion, '/')[0];
  {
    apiVersion: obj.apiVersion,
    apigroup:: if apigrp == 'v1' then '' else apigrp,
    kind: obj.kind,
    name: obj.metadata.name,
    namespace: if std.objectHas(obj.metadata, 'namespace') then obj.metadata.namespace,
  };

local patchName(targetObj) =
  local target = targetData(targetObj);

  // Some objects like ClusterRoleBinding can contain colons.
  local name = std.strReplace(target.name, ':', '-');
  local unhashed = '%s-%s-%s-%s-%s' % [ instance, target.kind, target.apigroup, target.namespace, name ];
  // Take 15 characters of the md5 hash, to leave room for a human-readable
  // prefix.
  local hashed = std.substr(std.md5(unhashed), 0, 15);

  local prefix =
    local p =
      if target.namespace != null then
        // for namespaced objects, use `<ns>-<name>` as the prefix
        '%s-%s' % [ std.asciiLower(target.namespace), name ]
      else
        // for cluster-scoped objects, use `<kind>-<name>` as the prefix
        // We could also add `<apigroup>` in the prefix, but we don't
        // need to do this, since the apigroup is part of the hashed string.
        '%s-%s' % [ std.asciiLower(target.kind), name ];
    // Trim the prefix if it's too long, make sure the kind/namespace part of
    // the prefix remains.
    if std.length(p) > 31 then
      std.substr(p, 0, 31)
    else
      p;

  local n = '%s-%s' % [ prefix, hashed ];

  // We generate names with a max length of 47, so there's a few characters
  // left for adding `manager` in `clusterRoleName()` and `saname`.
  assert
    std.length(n) <= 47 :
    "name generated by rl_obj_name() is longer than 47 characters, this shouldn't happen";
  n;

local Patch(targetobj, patchTemplate, patchStrategy='application/strategic-merge-patch+json') =
  local name = patchName(targetobj);
  local asFilter = function(obj) {
    kinds: [ '%s/%s' % [ obj.apiVersion, obj.kind ] ],
    [if std.objectHas(obj.metadata, 'namespace') && obj.metadata.namespace != null then 'namespaces']: [ obj.metadata.namespace ],
    names: [ obj.metadata.name ],
  };
  local rule = {
    match: {
      any: [
        { resources: asFilter(targetobj) },
      ],
    },
    mutate: {
      patchStrategicMerge: patchTemplate,
      // Kyverno crashes if this is not set to an empty array.
      targets: [],
    },
  };
  local target = {
    apiVersion: targetobj.apiVersion,
    kind: targetobj.kind,
    name: targetobj.metadata.name,
    namespace: if std.objectHas(targetobj.metadata, 'namespace') then targetobj.metadata.namespace,
  };
  [
    kyverno.ClusterPolicy(name) {
      spec: {
        mutateExistingOnPolicyUpdate: true,
        background: true,
        rules: [
          // This rule updates the target object on change of this policy.
          // It adds the `.mutate.targets` field to the object which allows Kyverno to update existing objects.
          rule {
            name: 'change-existing',
            mutate+: { targets: [ target ] },
          },
          // This rule creates a admission webhook for the target object. e.g. overrides changes
          // It does not have a `.mutate.targets` field, as this blocks Kyverno from creating the webhook to block changes.
          rule {
            name: 'webhook',
          },
        ],
      },
    },
  ];

local Resource(obj) =
  error "kyverno doesn't support kind `Resource`, please manage full resources directly in your component";

{
  apiVersion: apiVersion,
  Resource: Resource,
  Patch: Patch,
  renderPatch: render_patch,
}
